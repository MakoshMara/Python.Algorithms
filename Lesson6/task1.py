# Для анализа была взята задача №2 из домашней работы к уроку №2:
# Посчитать четные и нечетные цифры введенного натурального числа. Например, если введено число 34560, в нем 3 четные цифры (4, 6 и 0) и 2 нечетные
import sys
from collections import Counter


# Чтоб скучно не было портить реализацию, добавила новую коллекцию:)

def show(x):
    sum_mem = 0
    print(x)
    for i in x:
        print(f'{type(x.get(i))=}, {sys.getsizeof(x.get(i))=}, {x.get(i)=}')
        sum_mem = sum_mem + sys.getsizeof(x.get(i))
    print(f'Всего выделено на переменные - {sum_mem}')


# Вариант №1 (изначальный)
def shetchik1(n):
    ch = 0
    notch = 0
    while n > 0:
        if (n % 10) % 2 == 0:
            ch += 1
        else:
            notch += 1
        n = n // 10
    print(f'Четных - {ch},Нечетных - {notch}')
    return locals()


# Вариант №2 (c использованием Counter)
def shetchik2(str):
    res = []
    for i in str:
        if int(i) % 2 == 0:
            res.append(0)
        else:
            res.append(1)
    c = Counter(res)
    print(f'Четных - {c[0]},Нечетных - {c[1]}')
    return locals()


# Вариант №2 (c использованием словаря)
def shetchik3(s):
    n = list(s)
    c = {'ch': 0, 'notch': 0}
    for i in n:
        if int(i) % 2 == 0:
            c['ch'] += 1
        else:
            c['notch'] += 1
    print(f'Четных - {c["ch"]},Нечетных - {c["notch"]}')
    return locals()


show(shetchik1(19523665))
print('*' * 10)  # Всего выделено на переменные - 40
show(shetchik2('19523665'))
print('*' * 10)  # Всего выделено на переменные - 255
show(shetchik3('19523665'))
print('*' * 10)  # Всего выделено на переменные - 247


# Использовался Python 3.8.3 on win32, разрядность системы - 64
# Выводы: Самый затратный вариант  - вариант 2, с Counter. Притом от варианта №3 (со словарем) он отличается на 8 байт,
# которые относятся именно к переменной типа Counter. Второй и третий варианты потребляют в 6+ раз больше памяти чем первый. Притом что при увеличении исходного аргумента,
# разница будет увеличиваться, так кк списки будут съедать все больше места.
# Выводы в целом очевидны: не стоит использовать списки и сложные коллекции там, где можно обойтись без них


# Для эксперимента взяла еще одну задачу.
# Для анализа была взята задача №4 из домашней работы к уроку №2 (Она же из ДЗ №4):
# Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…
# Вариант №1 (через цикл)
def func_loop(n):
    i = 1
    s = 0
    for k in range(n):
        s += i
        i /= -2
    return locals()


# Вариант №2 (c использованием списков)
def func_another(n, b=1):
    r = [b]
    while len(r) < n:
        r.append(b / (-2))
        b = b / (-2)
    s = sum(r)
    return locals()


# Вариант №3 (c использованием списков и второго цикла)
def func_another2(n, b=1):
    r = [1]
    s = 0
    if n == 1:
        return s == b
    else:
        while len(r) < n:
            r.append(b / (-2))
            b = b / (-2)
            s = 0
            for j in r:
                s += j
    return locals()


show(func_loop(7))  # Всего выделено на переменные - 60
print('*' * 10)
show(func_another(7))  # Всего выделено на переменные - 110
print('*' * 10)
show(func_another2(7))  # Всего выделено на переменные - 126
print('*' * 10)

# Использовался Python 3.8.3 on win32, разрядность системы - 64
# Выводы: Ожидаемо, самый неэффективный вариант (№3) занимает больше всего места.
# Но в отличие от эксперимента со скоростью - не критично (на размер переменной j = 16 байт).
# Вывод в целом примерно такой же как и в первом случае (не надо списков, там где можно без них)
